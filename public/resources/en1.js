const page = `THE OBJECTIVE OF this book is to study a broad variety of
  important  and useful  algorithms:  methods for solving  problems 
  that are suited for computer implementation. We shall deal with many
  different areas of application, always concentrating on fundamental
  algorithms that are important to know and interesting to study. We
  shall spend enough time on each algorithm to understand its essential
  characteristics and to respect its subtleties. Our goal is to learn a large
  number of the most important algorithms used on computers today,
  well enough to be able to use and appreciate them.
  The strategy that we use for understanding the programs presented in this book is to implement and test them, to experiment with
  their variants, to discuss their operation on small examples, and to try
  them out on larger examples similar to what we might encounter in
  practice. We shall use the C programming language to describe the
  algorithms, thus providing useful implementations at the same time.
  Our programs have a uniform style that is amenable to translation into
  other modem programming languages, as well.
  We also pay careful attention to performance characteristics of
  our algorithms, to help us develop improved versions, compare different algorithms for the same task, and predict or guarantee performance
  for large problems. Understanding how the algorithms perform might
  require experimentation or mathematical analysis or both. We consider detailed information for many of the most important algorithms,
  developing analytic results directly when feasible, or calling on results
  from the research literature when necessary.
  To illustrate our general approach to developing algorithmic solutions, we consider in this chapter a detailed example comprising a
  number of algorithms that solve a particular problem. The problem
  that we consider is not a toy problem; it is a fundamental computational task, and the solution that we develop is of use in a variety
  of applications. We start with a simple solution, then seek to understand that solution's performance characteristics, which help us to see
  how to improve the algorithm. After a few iterations of this process,
  we come to an efficient and useful algorithm for solving the problem.
  This prototypical example sets the stage for our use of the same general
  methodology throughout the book.
  We conclude the chapter with a short discussion of the contents
  of the book, including brief descriptions of what the major parts of
  the book are and how they relate to one another.
  When we write a computer program, we are generally implementing
  a method that has been devised previously to solve some problem.
  This method is often independent of the particular computer to be
  used-it is likely to be equally appropriate for many computers and
  many computer languages. It is the method, rather than the computer
  program itself, that we must study to learn how the problem is being
  attacked. The term algorithm is used in computer science to describe
  a problem-solving method suitable for implementation as a computer
  program. Algorithms are the stuff of computer science: They are
  central objects of study in many, if not most, areas of the field.
  Most algorithms of interest involve methods of organizing the
  data involved in the computation. Objects created in this way are
  called data structures, and they also are central objects of study in
  computer science. Thus, algorithms and data structures go hand in
  hand. In this book we take the view that data structures exist as the
  byproducts or end products of algorithms, and thus that we must study
  them in order to understand the algorithms. Simple algorithms can
  give rise to complicated data structures and, conversely, complicated
  algorithms can use simple data structures. We shall study the properties
  of many data structures in this book; indeed, the book might well have
  been called Algorithms and Data Structures in C.
  When we use a computer to help us solve a problem, we typically
are faced with a number of possible different approaches. For small
problems, it hardly matters which approach we use, as long as we
have one that solves the problem correctly. For huge problems (or
applications where we need to solve huge numbers of small problems),
however, we quickly become motivated to devise methods that use
time or space as efficiently as possible.
The primary reason for us to learn about algorithm design is
that this discipline gives us the potential to reap huge savings, even
to the point of making it possible to do tasks that would otherwise
be impossible. In an application where we are processing millions of
objects, it is not unusual to be able to make a program millions of
times faster by using a well-designed algorithm. We shall see such an
example in Section 1.2 and on numerous other occasions throughout
the book. By contrast, investing additional money or time to buy and
install a new computer holds the potential for speeding up a program
by perhaps a factor of only 10 or 100. Careful algorithm design is
an extremely effective part of the process of solving a huge problem,
whatever the applications area.
When a huge or complex computer program is to be developed,
a great deal of effort must go into understanding and defining the
problem to be solved, managing its complexity, and decomposing it
into smaller subtasks that can be implemented easily. Often, many
of the algorithms required after the decomposition are trivial to implement. 
In most cases, however, there are a few algorithms whose
choice is critical because most of the system resources will be spent
running those algorithms. Those are the types of algorithms on which
we concentrate in this book. We shall study a variety of fundamental
algorithms that are useful for solving huge problems in a broad variety
of applications areas.
The sharing of programs in computer systems is becoming more
widespread, so, although we might expect to be using a large fraction
of the algorithms in this book, we also might expect to have to implement 
only a smaller fraction of them. However, implementing simple
versions of basic algorithms helps us to understand them better and
thus to use advanced versions more effectively. More important, the
opportunity to reimplement basic algorithms arises frequently. The
primary reason to do so is that we are faced, all too often, with 
completely new computing environments (hardware and software) with
new features that old implementations may not use to best advantage.
In other words, we often implement basic algorithms tailored to our
problem, rather than depending on a system routine, to make our solutions 
more portable and longer lasting. Another common reason to
reimplement basic algorithms is that mechanisms for sharing software
on many computer systems are not always sufficiently powerful to allow us 
to tailor standard programs to perform effectively on specific
tasks (or it may not be convenient to do so), so it is sometimes easier
to do a new implementation.
Computer programs are often overoptimized. It may not be
worthwhile to take pains to ensure that an implementation of a particular 
algorithm is the most efficient possible unless the algorithm is to
be used for an enormous task or is to be used many times. Otherwise,
a careful, relatively simple implementation will suffice: We can have
some confidence that it will work, and it is likely to run perhaps five or
10 times slower at worst than the best possible version, which means
that it may run for an extra few seconds. By contrast, the proper choice
of algorithm in the first place can make a difference of a factor of 100
or 1000 or more, which might translate to minutes, hours, or even
more in running time. In this book, we concentrate on the simplest
reasonable implementations of the best algorithms.
The choice of the best algorithm for a particular task can be
a complicated process, perhaps involving sophisticated mathematical
analysis. The branch of computer science that comprises the study of
such questions is called analysis ofalgorithms. Many of the algorithms
that we study have been shown through analysis to have excellent performance; 
others are simply known to work well through experience.
Our primary goal is to learn reasonable algorithms for important tasks,
yet we shall also pay careful attention to comparative performance of
the methods. We should not use an algorithm without having an idea
of what resources it might consume, and we strive to be aware of how
our algorithms might be expected to perform.
`
const par_1_ru = `
Предисловие
Зта книга знакомит вас с наиболее важными из применяемых на сегодняшний день
компьютерных алгоритмов, а также обучает, фундаментальным технологиям, кото¬
рые непосредственно адресованы все возрастающему количеству разработчиков,
нуждающихся в подобных знаниях. Она может быть использована как учебник для сту¬
дентов второго, третьего или четвертого курсов факультетов, связанных с компьютер¬
ными науками, после того как студенты овладели основными навыками и ознакомле¬
ны с компьютерными системами. Книга также может быть полезной для тех, кто
занимается самообразованием, или служить в качестве справочника для тех, кого ин¬
тересует разработка компьютерных систем или прикладных программ, поскольку она
содержит программные реализации полезных алгоритмов и подробную информацию о
рабочих характеристиках этих алгоритмов. В более широкой перспективе эту книгу
можно рассматривать как подходящее введение в данную предметную область.
В новом издании текст был полностью переработан, в него было включено более
тысячи новых упражнений, более сотни новых рисунков и десятки новых программ.
Кроме того, все рисунки были снабжены подробными комментариями. Этот новый
материал охватывает как новые темы, так и более полно поясняет многие классичес¬
кие алгоритмы. Большое внимание, уделенное в книге абстрактным типам данных,
расширяет сферу применения приведенных программ и делает их более пригодными
для современных сред программирования. Читатели, знакомые с предыдущими изда¬
ниями книги, найдут в ней множество новой информации; каждый читатель найдет в
книге большой объем учебного материала, который позволит успешно изучить наибо¬
лее важные понятия.
Вследствие большого объема нового материала, мы разбили новое издание на два
тома (каждый примерно равен по объему предыдущему изданию), первый из них пе¬
ред вами. Этот том охватывает фундаментальные понятия, структуры данных, алгоритмы
сортировки и алгоритмы поиска; во втором томе рассматриваются более развитые алго¬
ритмы и более сложные приложения, построенные на базе абстракций и методов, разра¬
ботанных в первом томе. Почти весь материал по основным принципам и структурам
данных, изложенный в этом издании, в предыдущих изданиях книги не рассматривался.
Эта книга адресована не только программистам и студентам, изучающим программи¬
рование и компьютерные науки. Практически каждый, кто пользуется компьютером, же¬
лает работать на нем быстрее или решать более сложные задачи. Алгоритмы, приведенные
в этой книге, представляют квинтэссенцию знаний, накопленную более чем за 50 лет, без
которых нельзя обойтись в многочисленных приложениях для эффективного использова¬
ния компьютера. От задач моделирования систем из N тел в физике и до задач анали!б ге¬
нетического кода в молекулярной биологии, описанные здесь базовые методы стали важ¬
ными составляющими современных научных исследований; от систем баз данных до
механизма поиска в Internet они стали базовыми компонентами современных про¬
граммных систем. По мере того, как сфера применения компьютерных приложений
становится все шире, возрастает влияние многих из рассмотренных здесь базовых ме¬
тодов. Данная книга может быть использована как источник информации для студен¬
тов и профессионалов, заинтересованных в ознакомлении и эффективном использова¬
нии описанных фундаментальных алгоритмов как основных инструментальных средств
для любых компьютерных приложений, какие они намерены разрабатывать.
Графы и алгоритмы на графах активно проникают во все современные компью¬
терные приложения. В этой книге описаны широко известные методы решения задач
обработки графов, которые возникают на практике. Ее основная цель заключается в
том, чтобы сделать эти методы и основные принципы, составляющие их основу, дос¬
тупными для все большего числа людей, которые в них нуждаются. Предлагаемый ма¬
териал книги представлен таких образом, что сначала излагаются начальные сведения,
начиная с базовой информации и основных понятий, с постепенным переходом к
анализу классических методов, и завершается изучением современных технологий, ко¬
торые все еще находятся на стадии разработки. Тщательно подобранные примеры,
подробные рисунки и завершенные программные реализации сопровождаются под¬
робным описанием алгоритмов и приложений.
Книга исключительно полезна на ранних стадиях курса обучения компьютерным
наукам, сразу после того, как студенты получат основные навыки программирования
и ознакомятся с компьютерными системами, и в то же время перед тем, как присту¬
пят к изучению специальных курсов по современным областям компьютерных наук
или прикладных вычислительных систем. Эта книга будет полезна как материал для
самообразования или как справочное пособие для специалистов, занятых разработкой
компьютерных систем или компьютерных приложений, поскольку она содержит про¬
граммные реализации полезных алгоритмов и подробные данные о рабочих характе¬
ристиках этих алгоритмов. Широкая перспектива, открывающаяся перед ними, делает
эту книгу подходящим введением в указанную выше область знаний.
Автор полностью переделал текст книги для этого издания и добавил несколько
тысяч упражнений, сотни новых иллюстраций, десятки новых программ и снабдил все
рисунки и программы развернутыми комментариями. Этот новый материал содержит
как описание новых тем, так и более полный анализ многих классических алгоритмов.
На протяжении всей книги основное внимание уделяется абстрактным типам данных,
которые существенно расширяют область применения программ и делают их исполь¬
зование более эффективным. Те, кто знаком с предыдущими изданиями настоящей
книги, найдут в ней много новой информации; все читатели найдут в ней массу по¬
лезного педагогического материала, который обеспечивает четкое понимание основ¬
ных понятий.
Книга предназначена не только для программистов и студентов, изучающих компь¬
ютерные науки. Все, кто работает с компьютером, хотят работать быстрее и решать
все более крупные задачи. Алгоритмы, которые мы изучаем, представляют собой об¬
ласть знаний, быстро развивавшуюся в течение последних пятидесяти лет и ставшую
основой для эффективного использования компьютера на широком множестве прило¬
жений. Начиная с задач моделирования систем из N тел в физике и заканчивая задача¬
ми анализа генетического кода в молекулярной биологии, описанные здесь^базовые
методы стали основной частью современных научных исследований; от систем баз
данных до механизмов поиска в Intenet они стали важной частью современных про¬
граммных систем. По мере того, как сфера применения компьютерных приложений
становится все шире, возрастает значение многих из базовых алгоритмов, особенно
фундаментальных алгоритмов на графах, описание которых дано в этом томе. Назна¬
чение этой книги состоит в том, чтобы стать источником информации для студентов и
профессионалов, чтобы они понимали и при необходимости искусно использовали ал¬
горитмы на графах в любом компьютерном приложении, каким бы оно ни было.
`
const par_2_ru = `
Круг рассматриваемых вопросов
Книга содержит 22 главы, сгруппированных в виде пяти основных частей: основ¬
ные понятия, структуры данных, сортировка, поиск и алгоритмы на графах. Приве¬
денные в ней описания призваны ознакомить читателей с основными свойствами мак¬
симально широкого круга фундаментальных алгоритмов. Описанные здесь алгоритмы
находят широкое применение на протяжении многих лет и являются существенно важ¬
ными как для профессиональных программистов, так и для студентов, изучающих
компьютерные науки. Все описанные в книге хитроумные методы, от биномиальных
очередей до trie-деревьев, относятся к базовым концепциям, лежащим в основе ком¬
пьютерных наук. Основной целью при написании этих книг было собрать воедино
фундаментальные методы из этих различных областей дискретной математики с целью
ознакомления с лучшими методами решения задач с помощью компьютера.
По достоинству вы сможете оценить собранный в книге материал, имея за плечами
курсы по изучению основных принципов разработки и анализа алгоритмов и опыт
программирования на языках высокого уровня, таких как C++, Java, или С. Эта кни¬
га предполагает наличие у читателя соответствующей подготовки. Данный том предпо¬
лагает знание массивов, связных списков, абстрактных типов данных (АТД), в нем ис¬
пользуются очереди по приоритету, таблицы символов, АТД объединения-поиска -
все эти понятия подробно рассматриваются в частях 1-4 (и во многих других коммен¬
тариях к алгоритмам и структурах данных).
Базовые свойства графов и алгоритмов на графах разработаны на базе основных
понятий, в то же время для их полного понимания очень часто необходимо глубоко
погружаться в пучину сложных математических выкладок. Несмотря на то что обсуж¬
дение современных математических понятий носит конспективный характер, на уров¬
не общих рассуждений и описаний, от читателя, тем не менее, требуется более высо¬
кая математическая подготовка, чем для работы с материалами, содержащимися в
частях 1-4. Несмотря на это, читатели, обладающие различными уровнями математи¬
ческой подготовки, извлекут для себя немалую пользу из этой книги. К такому подхо¬
ду вынуждает следующее обстоятельство: некоторые элементарные алгоритмы на гра¬
фах, которые могут быть понятны и использоваться каждым, лишь немногим
отличаются от развитых алгоритмов, которые понимает далеко не каждый. Основная
цель в подобных случаях — поместить важные алгоритмы в контекст других методов, а
не требовать изучения всего математического материала. Однако строгий подход, на
котором настаивают высококвалифицированные математики, часто приводит нас к со¬
зданию хороших программ, в связи с чем автор стремился сохранить баланс между
формальным подходом, на котором настаивают теоретики, и изложением материала,
рекомендуемом практиками, не жертвуя при этом строгостью.
`
const par_3_ru = `
Использование материала в рамках учебных курсов
Что касается стиля изложения материала, то в этом плане преподавателю предос¬
тавляется свобода в широких пределах, в зависимости от предпочтений преподавателя
и подготовки студентов. Описанные в книге алгоритмы широко использовались в те¬
чение многих лет, они представляют собой совокупность знаний, необходимых как
программисту-практику, так и студенту, изучающему теорию вычислительных систем.
В данной книге содержится объем основного материала, достаточный для того, чтобы
ее можно было использовать в качестве учебника по курсу алгоритмов и структур
данных, в то же время она содержит достаточно материала, чтобы быть использован¬
ной в качестве учебника по курсу алгоритмов на графах. Возможно, одни преподава¬
тели будут уделять основное внимание реализациям и практическим вопросам, а дру¬
гие - анализу и теоретическим исследованиям.
Данная книга ориентирована на изучение алгоритмов, которые, скорее всего, бу¬
дут использованы на практике. В ней содержится достаточно подробная информация
об инструментальных средствах, позволяющих читателям уверенно реализовывать, от¬
лаживать и запускать в работу алгоритмы решения различных задач или снабжать при¬
ложения необходимыми функциональными возможностями. В книгу включены полные
реализации рассматриваемых в ней методов, равно как и описание работы этих про¬
грамм на специально подобранном множестве примеров. Поскольку мы работаем с
реальными программными кодами, а не пользуемся псевдокодами, эти программы
можно быстро запустить в работу в рамках практических приложений.
Действительно, одним из практических применений этих алгоритмов было создание
сотен иллюстраций для данной книги. Благодаря этим иллюстрациям, суть многих ал¬
горитмов становится понятной на интуитивном уровне.
В книге подробно рассматриваются рабочие характеристики алгоритмов и ситуа¬
ции, в которых эти алгоритмы могут быть полезны. В контексте прослеживается связь
с анализом алгоритмов и теорией вычислительных систем. Чтобы показать, почему
предпочтение отдается тому или иному алгоритму, там, где это уместно, приводятся
результаты эмпирических и аналитических исследований. В представляющих интерес
случаях дается описание взаимосвязи между рассматриваемыми практическими алго¬
ритмами и чисто теоретическими результатами. Специальная информация по рабочим
характеристикам алгоритмов и их реализациям обобщается, выделяется и обсуждается
на протяжении всей книги.

`
const par_4_ru =`
Язык программирования
Во всех реализациях используется язык программирования С. Каждый конкретный
язык программирования имеет свои преимущества и недостатки; мы используем язык
С, так как он легко доступен и обладает свойствами, которые требуются для наших
приложений. Программные реализации можно легко перевести на любой другой со¬
временный язык программирования, так как в языке С имеется лишь небольшое чис¬
ло конструкций, характерных только для него. Мы используем стандартные идиомы
языка С там, когда в этом возникает необходимость, но назначение этой книги состо¬
ит не в том, чтобы служить справочным пособием по программированию на С.
В эту редакцию книги включено множество новых программ, многие из старых
программ были переделаны, главным образом, в силу того, чтобы их можно было ис¬
пользовать как реализации абстрактных типов данных. Обширные эмпирические ис¬
следования и сравнения программ проводятся на протяжении всего текста книги.
Цель данной книги заключается в том, чтобы представить алгоритмы в максималь¬
но простой и понятной форме. Везде, где это возможно, мы стремились сохранить
этот стиль, чтобы сходные по выполняемым действиям программы выглядели похожи¬
ми. Для многих алгоритмов в этой книге это подобие сохраняется независимо от язы¬
ка: быстрая сортировка (если выбирать какой-либо яркий пример) так и остается бы¬
строй сортировкой независимо от того, какой язык выбран для реализации ее
алгоритма: Algol-60, Basic, Fortran, Smalltalk, Ada, Pascal, C, PostScript, Java или ка¬
кой-то другой из бесчисленного множества языков и сред программирования, в кото¬
рых она показала себя эффективным методом сортировки.
Мы стремимся к изящным, компактным, эффективным и переносимым реализаци¬
ям, однако мы придерживаемся той точки зрения, что главное - это эффективность,
поэтому мы стараемся не упустить из виду рабочие характеристики создаваемых нами
программ на всех стадиях разработки.
`
const par_4_ru = `
Благодарности
Многие читатели прислали мне исключительно полезные отзывы о предыдущих из¬
даниях этой книги. В частности, в течение ряда лет предварительные наброски книги
апробировались на сотнях студентов в Принстоне и Брауне. Особую благодарность хо¬
телось бы выразить Трине Эйвери (Tina Avery) и Тому Фримену (Tom Freeman) за
оказанную помощь в выпуске первого издания; Джанет Инсерпи (Janet Incerpi) за
проявленные ею творческий подход и изобретательность, чтобы заставить аппаратные
и программные средства нашей примитивной и давно устаревшей компьютеризиро¬
ванной издательской системы напечатать первое издание книги; Марку Брауну (Mark
Brown) за его участие в исследованиях по визуализации алгоритмов, которые во мно¬
гом способствовали появлению в книге многочисленных рисунков, а также Дэйву
Хенсону (Dave Hanson) и Эндрю Эппелю (Andrew Appel) за их постоянную готов¬
ность ответить на мои вопросы, связанные с языками программирования. Я хотел бы
также поблагодарить многочисленных читателей, приславших отзывы на различные из¬
дания этой книги, в том числе Гая Олмсу, Джона Бентли, Марка Брауна, Джея Гри-
шера, Аллана Хейдона, Кеннеди Лемке, Юди Манбер, Дану Ричардс, Джона Рейфа,
М. Розенфельда, Стивена Сейдмана, Майка Квина и Вильяма Варда.
При подготовке нового издания я имел удовольствие работать с Питером Гордоном
(Peter Gordon), Дебби Лафферти (Debbie Lafferty) из издательства Addison-Wesley, кото¬
рые терпеливо опекали этот проект с момента его зарождения. Большое удовольствие до¬
ставила мне совместная работа с другими штатными сотрудниками этого издательства. Ха¬
рактер проекта сделал подготовку издания данной книги несколько непривычной задачей
для многих из них, и я высоко ценю проявленную ими снисходительность.
В процессе написания этой книги я приобрел трех новых наставников и хочу осо¬
бо выразить им свою признательность. Во-первых, Стиву Саммиту (Steve Summit), ко¬
торый внимательно проверил на техническом уровне первые варианты рукописи и
предоставил буквально тысячи подробных комментариев, особенно в отношении про¬
грамм. Стив хорошо понимал мое стремление снабдить книгу изящными и эффектив¬
ные реализациями, и его комментарии помогли мне не только обеспечить определен¬
ное единообразие реализаций, но и существенно улучшить многие из них. Во-вторых,
хочу поблагодарить Лин Дюпре (Lyn Dupre) за тысячи подробных комментариев в от¬
ношении рукописи, которые помогли не только избежать и исправить грамматические
ошибки, но и (что значительно важнее) выработать последовательный и связный стиль
написания, что позволило собрать воедино устрашающую массу технического материа¬
ла. Я исключительно благодарен полученной возможности поучиться у Стива и Лин -
их вклад в разработку этой книги оказался решающим.
Многое из написанного здесь я узнал из лекций и трудов Дона Кнута (Don
Knuth) - моего наставника в Стэнфорде. Хотя непосредственно Дон и не участвовал
в написании этой книги, его влияние можно почувствовать на всем ее протяжении,
ибо именно он поставил изучение алгоритмов на научную основу, благодаря чему во¬
обще стало возможным появление подобного рода книг. Мой друг и коллега Филлип
Флажоле (Philippe Flajolet), благодаря которому анализ алгоритмов стал вполне сфор¬
мировавшейся областью исследований, оказал такое же влияние этот труд.
Я глубоко признателен за оказанную мне поддержку Принстонскому университету,
Брауновскому университету и Национальному институту исследований в области ин¬
форматики и автоматики (INRIA - Institute de Recherche en Informatique and
Automatique), где я проделал большую часть работы над книгой, а также Институту
исследований проблем безопасности и Исследовательскому центру компании Xerox в
Пало-Альто, где была проделана часть работы во время моих визитов туда. В основу
многих глав этой книги положены исследования, которые щедро финансировались
Национальным научным фондом и Отделом военно-морских исследований. И в заклю¬
чение, я благодарю Билла Боуэна (Bill Bowen), Аарона Лемоника (Aaron Lemonick) и
Нейла Руденштайна (Neil Rudenstine) за то, что они способствовали созданию в
Принстоне академической обстановки, в которой я получил возможность подготовить
эту книгу, несмотря на множество других возложенных на меня обязанностей.
Роберт Седжвик
Марли-де-Руа, Франция, февраль 1983 г.
Принстон, Нью-Джерси, январь 1990 г.
Джеймстаун, Род-Айленд, август 2001 г.
Адаму, Эндрю, Бретт, Робби и, в первую очередь, Линде посвящается.
`
const par_5_ru = `
Примечания к упражнениям
Классификация упражнений - это занятие, сопряженное с рядом трудностей, по¬
скольку читатели такой книги, как эта, обладают различным уровнем знаний и опыта.
Тем не менее, определенное указание не помешает, поэтому многие упражнения по¬
мечены одним из четырех маркеров, дабы проще было выбрать соответствующий под¬
ход.
Упражнения, которые проверяют, насколько хорошо вы усвоили материал, помечены
незаполненным треугольником:
>	17.3. Составьте список неизоморфных циклов графа, представленного на рис. 17.1.
Например, если в вашем списке содержится цикл 3-4-5-3, в нем не могут нахо¬
диться циклы 3-5-4-3, 4-5-3-4, 4-3-5-4, 5-3-4-5 или 5-4-3-5.
Чаще всего такие упражнения непосредственно связаны с примерами в тексте.
Они не должны вызывать особых трудностей, но их выполнение может прояснить
факт или понятия, которые, возможно, ускользнули из вашего внимания во время
чтения текста.
Упражнения, которые дополняют текст новой и требующей размышления информаци¬
ей, помечены незаполненной окружностью:
о 18.6. Реализуйте DFS, используя свою независимую от представления АТД-функ-
цию для обработки списков ребер из упражнения 17.60.
Такие упражнения заставляют сосредоточиться на важных понятиях, связанных с
материалом, наложенным в тексте, или искать ответа на вопрос, который может воз¬
никнуть во время прочтения. Возможно, читатели сочтут полезным прочесть эти уп¬
ражнения дбже при отсутствии времени для их выполнения.
Упражнения, которые имеют цель поставить перед читателями задачу, помечены
черной точкой:
•	19.2. Назовите пример крупного графа DAG, описывающего какую-нибудь дея¬
тельность, выполняемую в интерактивном режиме, возможно, графа, определяемо¬
го зависимостями, связывающими определения функций в крупной системе про¬
граммного обеспечения, или связями каталогов в крупной файловой системе.
Для выполнения таких упражнений требуется потратить значительное время, в за¬
висимости от опыта читателя. В общем случае, лучше всего выполнять их в несколько
приемов.
Несколько упражнений, которые особенно трудны (по сравнению с большинством
других) помечены двумя черными точками:
•• 20.77. Разработайте алгоритм, который при заданном множестве N точек на плос¬
кости находит множество ребер, мощность которого пропорциональна N, и в ко¬
тором наверняка содержится дерево MST. Этот алгоритм должен содержать доста¬
точно легкие вычисления, чтобы можно было разработать компактную и
эффективную реализацию.
Эти упражнения аналогичны вопросам, которые могут ставиться в научной литера¬
туре, однако материал книги может так подготовить читателей, что им доставит удо¬
вольствие попытаться ответить на них (а, возможно, и преуспеть в этом).
Мы старались, чтобы все пометки были безотносительны к программной и матема¬
тической подготовке читателей. Те упражнения, которые требуют наличия опыта по
программированию или математическому анализу, очевидны. Мы настоятельно реко¬
мендуем читателям проверить свое понимание алгоритмов, реализовав их. Тем не ме¬
нее, упражнения, подобные приведенному ниже, просты для профессиональных про¬
граммистов или студентов, изучающих программирование, но могут потребовать
значительных усилий от тех, кто в последнее время по ряду причин программировани¬
ем не занимался:
•	17.73. Напишите программу, которая генерирует V случайных точек на плоскости,
после чего строит граф, состоящий из ребер, соединяющих все пары точек, уда¬
ленных друг от друга на расстояние, не превышающее d (см. рис. 17.13 и програм¬
му 3.20). Определите, какое значение d следует выбрать, чтобы ожидаемое число
ребер было равно Е. Проведите тестирование полученной программы в соответствии с
изложенным в упражнении 17.64 (для низких уровней насыщенности) и в соответствии
с изложенным в упражнении 17.65 (для высоких уровней насыщенности).
Мы настоятельно рекомендуем всем читателям стремиться учитывать приводимые
нами аналитические обоснования свойств всех алгоритмов. С другой стороны, упраж¬
нения, подобные нижеследующему, не составляют сложности для профессионального
математика или студента, изучающего дискретную математику, однако наверняка потребу¬
ют значительных усилий от тех, кто давно не занимался математическим анализом:
•	18.3. Сколько существует путей обхода лабиринта, показанного на рис. 18.2 и 18.3,
при проведении исследования Тремо?
Книга снабжена большим количеством упражнений, чтобы всех их можно было
прочесть и усвоить; тем не менее, я надеюсь, что среди них достаточно таких, кото¬
рые могут послужить мощным стимулом к углубленному пониманию интересующих их
вопросов, нежели простое чтение текста.
`

export default page
{"en":[{"label":"Preface","text":"\n<p>\nTHIS BOOK IS INTENDED to survey the most important computer algorithms in use today, \nand to teach fundamental techniques to\nthe growing number of people in need of knowing them. It can be\nused as a textbook for a second, third, or fourth course in computer\nscience, after students have acquired basic programming skills and familiarity with computer systems, but before they have taken specialized\ncourses in advanced areas of computer science or computer applications. The book also may be useful for self-study or as a reference for\n'people engaged in the development of computer systems or applications programs, since it contains implementations of useful algorithms\nand detailed information on these algorithms' performance characteristics. The broad perspective taken makes the book an appropriate\nintroduction to the field.\n</p>\n<p>\nI have completely rewritten the text for this new edition, and I\nhave added more than a thousand new exercises, more than a hundred\nnew figures, and dozens of new programs. I have also added detailed\ncommentary on all the figures and programs. This new material provides both coverage of new topics and fuller explanations of many of\nthe classic algorithms. A new emphasis on abstract data types throughout the book makes the programs more broadly useful and relevant in\nmodern object-oriented programming environments. People who have\nread old editions of the book will find a wealth of new information\nthroughout; all readers will find a wealth of pedagogical material that\nprovides effective access to essential concepts.\n</p>\n<p>\nDue to the large amount of new material, we have split the new\nedition into two volumes (each about the size of the old edition) of\nwhich this is the first. This volume covers fundamental concepts, data\nstructures, sorting algorithms, and searching algorithms; the second\nvolume covers advanced algorithms and applications, building on the\nbasic abstractions and methods developed here. Nearly all the material\non fundamentals and data structures in this edition is new.\n</p>\n<p>\nThis book is not just for programmers and computer-science students. Nearly everyone who uses a computer wants it to run faster\nor to solve larger problems. The algorithms in this book represent\na body of knowledge developed over the last 50 years that has become indispensible in the efficient use of the computer, for a broad\nvariety of applications. From N -body simulation problems in physics\nto genetic-sequencing problems in molecular biology, the basic methods described here have become essential in scientific research; and\nfrom database systems to Internet search engines, they have become\nessential parts of modern software systems. As the scope of computer\napplications becomes more widespread, so grows the impact of many\nof the basic methods covered here. The goal of this book is to serve\nas a resource for students and professionals interested in knowing and\nmaking intelligent use of these fundamental algorithms as basic tools\nfor whatever computer application they might undertake.\n</p>\n"},{"label":"Scope","text":"\n<p>\nTHE BOOK CONTAINS 16 chapters grouped into four major parts: fundamentals, data structures, sorting, and searching. The descriptions here\nare intended to give readers an understanding of the basic properties\nof as broad a range of fundamental algorithms as possible. Ingenious\nmethods ranging from binomial queues to patricia tries are described,\nall related to basic paradigms at the heart of computer science. The\nsecond volume consists of four additional parts that cover strings, geometry, graphs, and advanced topics. My primary goal in developing\nthese books has been to bring together the fundamental methods from\nthese diverse areas, to provide access to the best methods known for\nsolving problems by computer.\n</p>\n<p>\nYou will most appreciate the material in this book if you have had\none or two previous courses in computer science or have had equivalent\nprogramming experience: one course in programming in a high-level\nlanguage such as C, Java, or C++, and perhaps another course that\nteaches fundamental concepts of programming systems. This book\nis thus intended for anyone conversant with a modern programming\nlanguage and with the basic features of modern computer systems.\nReferences that might help to fill in gaps in your background are\nsuggested in the text.\n</p>\n<p>\nMost of the mathematical material supporting the analytic results\nis self-contained (or is labeled as beyond the scope of this book), so\nlittle specific preparation in mathematics is required for the bulk of the\nbook, although mathematical maturity is definitely helpful.\n</p>\n"},{"label":"Use in the Curriculum","text":"\n<p>\nTHERE IS A GREAT DEAL of flexibility in how the material here can be\ntaught, depending on the taste of the instructor and the preparation\nof the students. The algorithms described here have found widespread\nuse for years, and represent an essential body of knowledge for both\nthe practicing programmer and the computer-science student. There\nis sufficient coverage of basic material for the book to be used for a\ncourse on data structures, and there is sufficient detail and coverage of\nadvanced material for the book to be used for a course on algorithms.\nSome instructors may wish to emphasize implementations and practical concerns; others may wish to emphasize analysis and theoretical\nconcepts.\n</p>\n<p>\nA complete set of slide masters for use in lectures, sample programming assignments, interactive exercises for students, and other\ncourse materials may be found via the book's home page.\n</p>\n<p>\nAn elementary course on data structures and algorithms might\nemphasize the basic data structures in Part 2 and their use in the\nimplementations in Parts 3 and 4. A course on design and analysis of\nalgorithms might emphasize the fundamental material in Part 1 and\nChapter 5, then study the ways in which the algorithms in Parts 3\nand 4 achieve good asymptotic performance. A course on software\nengineering might omit the mathematical and advanced algorithmic\nmaterial, and emphasize how to integrate the implementations given\nhere into large programs or systems. A course on algorithms might\ntake a survey approach and introduce concepts from all these areas.\n</p>\n<p>\nEarlier editions of this book have been used in recent years at\nscores of colleges and universities around the world as a text for the\nsecond or third course in computer science and as supplemental reading\nfor other courses. At Princeton, our experience has been that the\nbreadth of coverage of material in this book provides our majors with\nan introduction to computer science that can be expanded upon in\nlater courses on analysis of algorithms, systems programming and\ntheoretical computer science, while providing the growing group of\nstudents from other disciplines with a large set of techniques that these\npeople can immediately put to good use.\n</p>\n<p>\nThe exercises-most of which are new to this edition-fall into\nseveral types. Some are intended to test understanding of material\nin the text, and simply ask readers to work through an example or\nto apply concepts described in the text. Others involve implementing\nand putting together the algorithms, or running empirical studies to\ncompare variants of the algorithms and to learn their properties. Still\nothers are a repository for important information at a level of detail\nthat is not appropriate for the text. Reading and thinking about the\nexercises will pay dividends for every reader.\n</p>\n"},{"label":"Algorithms of Practical Use","text":"\n<p>\nANYONE WANTING TO USE a computer more effectively can use this book\nfor reference or for self-study. People with programming experience\ncan find information on specific topics throughout the book. To a large\nextent, you can read the individual chapters in the book independently\nof the others, although, in some cases, algorithms in one chapter make\nuse of methods from a previous chapter.\n</p>\n<p>\nThe orientation of the book is to study algorithms likely to be of\npractical use. The book provides information about the tools of the\ntrade to the point that readers can confidently implement, debug, and\nput to work algorithms to solve a problem or to provide functionality\nin an application. Full implementations of the methods discussed are\nincluded, as are descriptions of the operations of these programs on\na consistent set of examples. Because we work with real code, rather\nthan write pseudo-code, the programs can be put to practical use\nquickly. Program listings are available from the book's home page.\n</p>\n<p>\nIndeed, one practical application of the algorithms has been to\nproduce the hundreds of figures throughout the book. Many algorithms are brought to light on an intuitive level through the visual\ndimension provided by these figures.\n</p>\n<p>\nCharacteristics of the algorithms and of the situations in which\nthey might be useful are discussed in detail. Although not emphasized,\nconnections to the analysis of algorithms and theoretical computer\nscience are developed in context. When appropriate, empirical and\nanalytic results are presented to illustrate why certain algorithms are\npreferred. When interesting, the relationship of the practical algorithms being discussed to purely theoretical results is described. Specific information on performance characteristics of algorithms and implementations is synthesized, encapsulated, and discussed throughout\nthe book.\n</p>\n"},{"label":"Programming Language","text":"\n<p>\nTHE PROGRAMMING LANGUAGE used for all of the implementations is C.\nAny particular language has advantages and disadvantages; we use\nC because it is widely available and provides the features needed for\nour implementations. The programs can be translated easily to other\nmodern programming languages, since relatively few constructs are\nunique to C. We use standard C idioms when appropriate, but this\nbook is not intended to be a reference work on C programming.\n</p>\n<p>\nThere are many new programs in this edition, and many of the\nold ones have been reworked, primarily to make them more readily\nuseful as abstract-data-type implementations. Extensive comparative\nempirical tests on the programs are discussed throughout the text.\n</p>\n<p>\nPrevious editions of the book have presented basic programs in\nPascal, C++, and Modula-3. This code is available through the book\nhome page on the web; code for new programs and code in new\nlanguages such as Java will be added as appropriate.\n</p>\n<p>\nA goal of this book is to present the algorithms in as simple and\ndirect a form as possible. The style is consistent whenever possible, so\nthat programs that are similar look similar. For many of the algorithms\nin this book, the similarities hold regardless of the language: Quicksort\nis quicksort (to pick one prominent example), whether expressed in\nAlgol-60, Basic, Fortran, Smalltalk, Ada, Pascal, C, PostScript, Java,\nor countless other programming languages and environments where it\nhas proved to be an effective sorting method.\n</p>\n<p>\nWe strive for elegant, compact, and portable implementations,\nbut we take the point of view that efficiency matters, so we try to\nhe aware of the performance characteristics of our code at all stages\nof development. Chapter 1 constitutes a detailed example of this\napproach to developing efficient C implementations of our algorithms,\nand sets the stage for the rest of the hook.\n</p>\n"},{"label":"Acknowledgments","text":"\n<p>\nMANY PEOPLE GAVE ME helpful feedback on earlier versions of this book.\nIn particular, hundreds of students at Princeton and Brown have suffered through preliminary drafts over the years. Special thanks are due\nto Trina Avery and Tom Freeman for their help in producing the first\nedition; to Janet Incerpi for her creativity and ingenuity in persuading\nour early and primitive digital computerized typesetting hardware and\nsoftware to produce the first edition; to Marc Brown for his part in\nthe algorithm visualization research that was the genesis of so many of\nthe figures in the book; and to Dave Hanson for his willingness to answer all of my questions about C. I would also like to thank the many\nreaders who have provided me with detailed comments about various\neditions, including Guy Almes, Jon Bentley, Marc Brown, Jay Gischer,\nAllan Heydon, Kennedy Lemke, Udi Manber, Dana Richards, John\nReif, M. Rosenfeld, Stephen Seidman, Michael Quinn, and William\nWard.\n</p>\n<p>\nTo produce this new edition, I have had the pleasure of working\nwith Peter Gordon and Debbie Lafferty at Addison-Wesley, who have\npatiently shepherded this project as it has evolved from a standard\nupdate to a massive rewrite. It has also been my pleasure to work with\nseveral other members of the professional staff at Addison-Wesley. The\nnature of this project made the book a somewhat unusual challenge\nfor many of them, and I much appreciate their forbearance.\n</p>\n<p>\nI have gained two new mentors in writing this book, and particularly want \nto express my appreciation to them. First, Steve Summit\ncarefully checked early versions of the manuscript on a technical level,\nand provided me with literally thousands of detailed comments, particularly \non the programs. Steve clearly understood my goal of providing\nelegant, efficient, and effective implementations, and his comments not\nonly helped me to provide a measure of consistency across the implementations, \nbut also helped me to improve many of them substantially.\nSecond, Lyn Dupre also provided me with thousands of detailed comments on \nthe manuscript, which were invaluable in helping me not only\nto correct and avoid grammatical errors, but also-more importantto find a \nconsistent and coherent writing style that helps bind together\nthe daunting mass of technical material here. I am extremely grateful\nfor the opportunity to learn from Steve and Lyn-their input was vital\nin the development of this book.\n</p>\n<p>\nMuch of what I have written here I have learned from the teaching\nand writings of Don Knuth, my advisor at Stanford. Although Don had\nno direct influence on this work, his presence may be felt in the book,\nfor it was he who put the study of algorithms on the scientific footing\nthat makes a work such as this possible. My friend and colleague\nPhilippe Flajolet, who has been a major force in the development of\nthe analysis of algorithms as a mature research area, has had a similar\ninfluence on this work.\n</p>\n<p>\nI am deeply thankful for the support of Princeton University,\nBrown University, and the Institut National de Recherce en Informatique et Automatique (INRIA), where I did most of the work on the\nbook; and of the Institute for Defense Analyses and the Xerox Palo\nAlto Research Center, where I did some work on the book while visiting. Many parts of the book are dependent on research that has been\ngenerously supported by the National Science Foundation and the Office of Naval Research. Finally, I thank Bill Bowen, Aaron Lemonick,\nand Neil Rudenstine for their support in building an academic environment at Princeton in which I was able to prepare this book, despite\nmy numerous other responsibilities.\n</p>\n<p>\nRobert Sedgewick\nMarly-le-Roi, France, February, 1983\nPrinceton, New Jersey, January, 1990\nJamestown, Rhode Island, August, 1997\n</p>\n"},{"label":"Notes on Exercises","text":"\n<p>\nCLASSIFYING EXERCISES IS an activity fraught with peril, because readers\nof a book such as this come to the material with various levels of\nknowledge and experience. Nonetheless, guidance is appropriate, so\nmany of the exercises carry one of four annotations, to help you decide\nhow to approach them.\n</p>\n<p>\nExercises that test your understanding of the material are marked\nwith an open triangle, as follows:\n9.57 Give the binomial queue that results when the keys E A S Y \nQUE S T ION are inserted into an initially empty binomial queue. \nMost often, such exercises relate directly to examples in the text. They\nshould present no special difficulty, but working them might teach you\na fact or concept that may have eluded you when you read the text.\nExercises that add new and thought-provoking information to the\nmaterial are marked with an open circle, as follows:\n014.20 Write a program that inserts N random integers into a \ntable of size N /100 using separate chaining, then finds the length \nof the shortest and longest lists, for N lO3, 104 , 105 , and 106 • \nSuch exercises encourage you to think about an important concept\nthat is related to the material in the text, or to answer a question that\nmay have occurred to you when you read the text. You may find it\nworthwhile to read these exercises, even if you do not have the time to\nwork them through.\nExercises that are intended to challenge you are marked with a black\ndot, as follows:\n• \t8.46 Suppose that mergesort is implemented to split the file at \na random position, rather than exactly in the middle. How many \ncomparisons are used by such a method to sort N elements, on \nthe average? \nSuch exercises may require a substantial amount of time to complete,\ndepending upon your experience. Generally, the most productive approach is to work on them in a few different sittings.\nA few exercises that are extremely difficult (by comparison with\nmost others) are marked with two black dots, as follows:\n•• 15.29 Prove that the height of a trie built from N random bit­\nstrings is about 21g N. \nThese exercises are similar to questions that might be addressed in the\nresearch literature, but the material in the book may prepare you to\nenjoy trying to solve them (and perhaps succeeding).\nThe annotations are intended to be neutral with respect to your\nprogramming and mathematical ability. Those exercises that require\nexpertise in programming or in mathematical analysis are self-evident.\nAll readers are encouraged to test their understanding of the algorithms\nby implementing them. Still, an exercise such as this one is straightforward for a practicing programmer or a student in a programming\ncourse, but may require substantial work for someone who has not\nrecently programmed:\n1.23 Modify Program 1.4 to generate random pairs of integers\nbetween 0 and ]V - 1 instead of reading them from standard input,\nand to loop until ]V - 1 union operations have been performed.\nRun your program for]V 103 , 10 105, and 106and print out\nthe total number of edges generated for each value of N.\nIn a similar vein, all readers are encouraged to strive to appreciate\nthe analytic underpinnings of our knowledge about properties of algorithms. Still, an exercise such as this one is straightforward for a\nscientist or a student in a discrete mathematics course, but may require\nsubstantial work for someone who has not recently done mathematical\nanalysis:\n1.13 Compute the average distance from a node to the root in\na worst-case tree of 2n nodes built by the weighted quick-union\nalgorithm.\nThere are far too many exercises for you to read and assimilate\nthem all; my hope is that there are enough exercises here to stimulate\nyou to strive to come to a broader understanding on the topics that\ninterest you than you can glean by simply reading the text.\n"}],"ru":[{"label":"Предисловие","text":"\n<p>\nЭТА КНИГА ЗНАКОМИТ вас с наиболее важными из применяемых на сегодняшний день\nкомпьютерных алгоритмов, а также обучает, фундаментальным технологиям, которые \nнепосредственно адресованы все возрастающему количеству разработчиков,\nнуждающихся в подобных знаниях. Она может быть использована как учебник для студентов \nвторого, третьего или четвертого курсов факультетов, связанных с компьютерными \nнауками, после того как студенты овладели основными навыками и ознакомлены \nс компьютерными системами. Книга также может быть полезной для тех, кто\nзанимается самообразованием, или служить в качестве справочника для тех, кого \nинтересует разработка компьютерных систем или прикладных программ, поскольку она\nсодержит программные реализации полезных алгоритмов и подробную информацию о\nрабочих характеристиках этих алгоритмов. В более широкой перспективе эту книгу\nможно рассматривать как подходящее введение в данную предметную область.\n</p>\n<p>\nВ новом издании текст был полностью переработан, в него было включено более\nтысячи новых упражнений, более сотни новых рисунков и десятки новых программ.\nКроме того, все рисунки были снабжены подробными комментариями. Этот новый\nматериал охватывает как новые темы, так и более полно поясняет многие классические \nалгоритмы. Большое внимание, уделенное в книге абстрактным типам данных,\nрасширяет сферу применения приведенных программ и делает их более пригодными\nдля современных сред программирования. Читатели, знакомые с предыдущими изданиями \nкниги, найдут в ней множество новой информации; каждый читатель найдет в\nкниге большой объем учебного материала, который позволит успешно изучить наиболее \nважные понятия.\n</p>\n<p>\nВследствие большого объема нового материала, мы разбили новое издание на два\nтома (каждый примерно равен по объему предыдущему изданию), первый из них \nперед вами. Этот том охватывает фундаментальные понятия, структуры данных, алгоритмы\nсортировки и алгоритмы поиска; во втором томе рассматриваются более развитые \nалгоритмы и более сложные приложения, построенные на базе абстракций и методов, \nразработанных в первом томе. Почти весь материал по основным принципам и структурам\nданных, изложенный в этом издании, в предыдущих изданиях книги не рассматривался.\n</p>\n<p>\nЭта книга адресована не только программистам и студентам, изучающим программирование \nи компьютерные науки. Практически каждый, кто пользуется компьютером, же\nлает работать на нем быстрее или решать более сложные задачи. Алгоритмы, приведенные\nв этой книге, представляют квинтэссенцию знаний, накопленную более чем за 50 лет, без\nкоторых нельзя обойтись в многочисленных приложениях для эффективного использования \nкомпьютера. От задач моделирования систем из N тел в физике и до задач анализа \nгенетического кода в молекулярной биологии, описанные здесь базовые методы стали \nважными составляющими современных научных исследований; от систем баз данных до\nмеханизма поиска в Internet они стали базовыми компонентами современных \nпрограммных систем. По мере того, как сфера применения компьютерных приложений\nстановится все шире, возрастает влияние многих из рассмотренных здесь базовых методов. \nДанная книга может быть использована как источник информации для студентов \nи профессионалов, заинтересованных в ознакомлении и эффективном использовании \nописанных фундаментальных алгоритмов как основных инструментальных средств\nдля любых компьютерных приложений, какие они намерены разрабатывать.\n</p>\n<p>\nГрафы и алгоритмы на графах активно проникают во все современные компьютерные \nприложения. В этой книге описаны широко известные методы решения задач\nобработки графов, которые возникают на практике. Ее основная цель заключается в\nтом, чтобы сделать эти методы и основные принципы, составляющие их основу, \nдоступными для все большего числа людей, которые в них нуждаются. Предлагаемый \nматериал книги представлен таких образом, что сначала излагаются начальные сведения,\nначиная с базовой информации и основных понятий, с постепенным переходом к\nанализу классических методов, и завершается изучением современных технологий, \nкоторые все еще находятся на стадии разработки. Тщательно подобранные примеры,\nподробные рисунки и завершенные программные реализации сопровождаются подробным \nописанием алгоритмов и приложений.\n</p>\n<p>\nКнига исключительно полезна на ранних стадиях курса обучения компьютерным\nнаукам, сразу после того, как студенты получат основные навыки программирования\nи ознакомятся с компьютерными системами, и в то же время перед тем, как приступят \nк изучению специальных курсов по современным областям компьютерных наук\nили прикладных вычислительных систем. Эта книга будет полезна как материал для\nсамообразования или как справочное пособие для специалистов, занятых разработкой\nкомпьютерных систем или компьютерных приложений, поскольку она содержит \nпрограммные реализации полезных алгоритмов и подробные данные о рабочих \nхарактеристиках этих алгоритмов. Широкая перспектива, открывающаяся перед ними, делает\nэту книгу подходящим введением в указанную выше область знаний.\n</p>\n<p>\nАвтор полностью переделал текст книги для этого издания и добавил несколько\nтысяч упражнений, сотни новых иллюстраций, десятки новых программ и снабдил все\nрисунки и программы развернутыми комментариями. Этот новый материал содержит\nкак описание новых тем, так и более полный анализ многих классических алгоритмов.\nНа протяжении всей книги основное внимание уделяется абстрактным типам данных,\nкоторые существенно расширяют область применения программ и делают их использование \nболее эффективным. Те, кто знаком с предыдущими изданиями настоящей\nкниги, найдут в ней много новой информации; все читатели найдут в ней массу \nполезного педагогического материала, который обеспечивает четкое понимание основных \nпонятий.\n</p>\n<p>\nКнига предназначена не только для программистов и студентов, изучающих компьютерные \nнауки. Все, кто работает с компьютером, хотят работать быстрее и решать\nвсе более крупные задачи. Алгоритмы, которые мы изучаем, представляют собой \nобласть знаний, быстро развивавшуюся в течение последних пятидесяти лет и ставшую\nосновой для эффективного использования компьютера на широком множестве приложений. \nНачиная с задач моделирования систем из N тел в физике и заканчивая задачами \nанализа генетического кода в молекулярной биологии, описанные здесь базовые\nметоды стали основной частью современных научных исследований; от систем баз\nданных до механизмов поиска в Intenet они стали важной частью современных \nпрограммных систем. По мере того, как сфера применения компьютерных приложений\nстановится все шире, возрастает значение многих из базовых алгоритмов, особенно\nфундаментальных алгоритмов на графах, описание которых дано в этом томе. Назначение \nэтой книги состоит в том, чтобы стать источником информации для студентов и\nпрофессионалов, чтобы они понимали и при необходимости искусно использовали \nалгоритмы на графах в любом компьютерном приложении, каким бы оно ни было.\n</p>\n"},{"label":"Круг рассматриваемых вопросов","text":"\n<p>\nКНИГА СОДЕРЖИТ 22 главы, сгруппированных в виде пяти основных частей: основные \nпонятия, структуры данных, сортировка, поиск и алгоритмы на графах. \nПриведенные в ней описания призваны ознакомить читателей с основными свойствами \nмаксимально широкого круга фундаментальных алгоритмов. Описанные здесь алгоритмы\nнаходят широкое применение на протяжении многих лет и являются существенно \nважными как для профессиональных программистов, так и для студентов, изучающих\nкомпьютерные науки. Все описанные в книге хитроумные методы, от биномиальных\nочередей до trie-деревьев, относятся к базовым концепциям, лежащим в основе\n компьютерных наук. Основной целью при написании этих книг было собрать воедино\nфундаментальные методы из этих различных областей дискретной математики с целью\nознакомления с лучшими методами решения задач с помощью компьютера.\n</p>\n<p>\nПо достоинству вы сможете оценить собранный в книге материал, имея за плечами\nкурсы по изучению основных принципов разработки и анализа алгоритмов и опыт\nпрограммирования на языках высокого уровня, таких как C++, Java, или С. Эта книга \nпредполагает наличие у читателя соответствующей подготовки. Данный том предполагает \nзнание массивов, связных списков, абстрактных типов данных (АТД), в нем \nиспользуются очереди по приоритету, таблицы символов, АТД объединения-поиска -\nвсе эти понятия подробно рассматриваются в частях 1-4 (и во многих других \nкомментариях к алгоритмам и структурах данных).\n</p>\n<p>\nБазовые свойства графов и алгоритмов на графах разработаны на базе основных\nпонятий, в то же время для их полного понимания очень часто необходимо глубоко\nпогружаться в пучину сложных математических выкладок. Несмотря на то что \nобсуждение современных математических понятий носит конспективный характер, \nна уровне общих рассуждений и описаний, от читателя, тем не менее, требуется \nболее высокая математическая подготовка, чем для работы с материалами, \nсодержащимися в частях 1-4. Несмотря на это, читатели, обладающие различными \nуровнями математической подготовки, извлекут для себя немалую пользу из этой книги. \nК такому подходу вынуждает следующее обстоятельство: некоторые элементарные алгоритмы \nна графах, которые могут быть понятны и использоваться каждым, лишь немногим\nотличаются от развитых алгоритмов, которые понимает далеко не каждый. Основная\nцель в подобных случаях — поместить важные алгоритмы в контекст других методов, а\nне требовать изучения всего математического материала. Однако строгий подход, на\nкотором настаивают высококвалифицированные математики, часто приводит нас к \nсозданию хороших программ, в связи с чем автор стремился сохранить баланс между\nформальным подходом, на котором настаивают теоретики, и изложением материала,\nрекомендуемом практиками, не жертвуя при этом строгостью.\n</p>\n"},{"label":"Использование материала в рамках учебных курсов","text":"\n<p>\nЧТО КАСАЕТСЯ СТИЛЯ изложения материала, то в этом плане преподавателю предоставляется \nсвобода в широких пределах, в зависимости от предпочтений преподавателя\nи подготовки студентов. Описанные в книге алгоритмы широко использовались в течение \nмногих лет, они представляют собой совокупность знаний, необходимых как\nпрограммисту-практику, так и студенту, изучающему теорию вычислительных систем.\nВ данной книге содержится объем основного материала, достаточный для того, чтобы\nее можно было использовать в качестве учебника по курсу алгоритмов и структурданных, \nв то же время она содержит достаточно материала, чтобы быть использован\nной в качестве учебника по курсу алгоритмов на графах. Возможно, одни преподаватели \nбудут уделять основное внимание реализациям и практическим вопросам, а другие - \nанализу и теоретическим исследованиям.\n</p>\n<p>\nДанная книга ориентирована на изучение алгоритмов, которые, скорее всего, \nбудут использованы на практике. В ней содержится достаточно подробная информация\nоб инструментальных средствах, позволяющих читателям уверенно реализовывать, от\nлаживать и запускать в работу алгоритмы решения различных задач или снабжать \nприложения необходимыми функциональными возможностями. В книгу включены полные\nреализации рассматриваемых в ней методов, равно как и описание работы этих программ \nна специально подобранном множестве примеров. Поскольку мы работаем с\nреальными программными кодами, а не пользуемся псевдокодами, эти программы\nможно быстро запустить в работу в рамках практических приложений.\n</p>\n<p>\nДействительно, одним из практических применений этих алгоритмов было создание\nсотен иллюстраций для данной книги. Благодаря этим иллюстрациям, суть многих \nалгоритмов становится понятной на интуитивном уровне.\n</p>\n<p>\nВ книге подробно рассматриваются рабочие характеристики алгоритмов и ситуации, \nв которых эти алгоритмы могут быть полезны. В контексте прослеживается связь\nс анализом алгоритмов и теорией вычислительных систем. Чтобы показать, почему\nпредпочтение отдается тому или иному алгоритму, там, где это уместно, приводятся\nрезультаты эмпирических и аналитических исследований. В представляющих интерес \nслучаях дается описание взаимосвязи между рассматриваемыми практическими алгоритмами\n и чисто теоретическими результатами. Специальная информация по рабочим\nхарактеристикам алгоритмов и их реализациям обобщается, выделяется и обсуждается\nна протяжении всей книги.\n</p>\n"},{"label":"Язык программирования","text":"\n<p>\nВО ВСЕХ РЕАЛИЗАЦИЯХ используется язык программирования С. Каждый конкретный\nязык программирования имеет свои преимущества и недостатки; мы используем язык\nС, так как он легко доступен и обладает свойствами, которые требуются для наших\nприложений. Программные реализации можно легко перевести на любой другой современный\nязык программирования, так как в языке С имеется лишь небольшое число конструкций,\nхарактерных только для него. Мы используем стандартные идиомы\nязыка С там, когда в этом возникает необходимость, но назначение этой книги\nсостоит не в том, чтобы служить справочным пособием по программированию на С.\n</p>\n<p>\nВ эту редакцию книги включено множество новых программ, многие из старых\nпрограмм были переделаны, главным образом, в силу того, чтобы их можно было \nиспользовать как реализации абстрактных типов данных. Обширные эмпирические \nисследования и сравнения программ проводятся на протяжении всего текста книги.\n</p>\n<p>\nЦель данной книги заключается в том, чтобы представить алгоритмы в максимально \nпростой и понятной форме. Везде, где это возможно, мы стремились сохранить\nэтот стиль, чтобы сходные по выполняемым действиям программы выглядели похожими. \nДля многих алгоритмов в этой книге это подобие сохраняется независимо от языка: \nбыстрая сортировка (если выбирать какой-либо яркий пример) так и остается бы\nстрой сортировкой независимо от того, какой язык выбран для реализации ее\nалгоритма: Algol-60, Basic, Fortran, Smalltalk, Ada, Pascal, C, PostScript, Java \nили какой-то другой из бесчисленного множества языков и сред программирования,\n в которых она показала себя эффективным методом сортировки.\n </p>\n <p>\nМы стремимся к изящным, компактным, эффективным и переносимым реализациям, \nоднако мы придерживаемся той точки зрения, что главное - это эффективность,\nпоэтому мы стараемся не упустить из виду рабочие характеристики создаваемых нами\nпрограмм на всех стадиях разработки.\n</p>\n"},{"label":"Благодарности","text":"\n<p>\nМНОГИЕ ЧИТАТЕЛИ прислали мне исключительно полезные отзывы о предыдущих изданиях \nэтой книги. В частности, в течение ряда лет предварительные наброски книги\nапробировались на сотнях студентов в Принстоне и Брауне. Особую благодарность \nхотелось бы выразить Трине Эйвери (Tina Avery) и Тому Фримену (Tom Freeman) за\nоказанную помощь в выпуске первого издания; Джанет Инсерпи (Janet Incerpi) за\nпроявленные ею творческий подход и изобретательность, чтобы заставить аппаратные\nи программные средства нашей примитивной и давно устаревшей компьютеризированной \nиздательской системы напечатать первое издание книги; Марку Брауну (Mark Brown) \nза его участие в исследованиях по визуализации алгоритмов, которые во многом \nспособствовали появлению в книге многочисленных рисунков, а также Дэйву\nХенсону (Dave Hanson) и Эндрю Эппелю (Andrew Appel) за их постоянную готовность \nответить на мои вопросы, связанные с языками программирования. Я хотел бы\nтакже поблагодарить многочисленных читателей, приславших отзывы на различные \nиздания этой книги, в том числе Гая Олмсу, Джона Бентли, Марка Брауна, \nДжея Гришера, Аллана Хейдона, Кеннеди Лемке, Юди Манбер, Дану Ричардс, \nДжона Рейфа, М. Розенфельда, Стивена Сейдмана, Майка Квина и Вильяма Варда.\n</p>\n<p>\nПри подготовке нового издания я имел удовольствие работать с Питером Гордоном\n(Peter Gordon), Дебби Лафферти (Debbie Lafferty) из издательства Addison-Wesley, \nкоторые терпеливо опекали этот проект с момента его зарождения. Большое удовольствие \nдоставила мне совместная работа с другими штатными сотрудниками этого издательства. \nХарактер проекта сделал подготовку издания данной книги несколько непривычной задачей\nдля многих из них, и я высоко ценю проявленную ими снисходительность.\n</p>\n<p>\nВ процессе написания этой книги я приобрел трех новых наставников и хочу особо \nвыразить им свою признательность. Во-первых, Стиву Саммиту (Steve Summit), \nкоторый внимательно проверил на техническом уровне первые варианты рукописи и\nпредоставил буквально тысячи подробных комментариев, особенно в отношении программ. \nСтив хорошо понимал мое стремление снабдить книгу изящными и эффективные \nреализациями, и его комментарии помогли мне не только обеспечить определенное \nединообразие реализаций, но и существенно улучшить многие из них. Во-вторых,\nхочу поблагодарить Лин Дюпре (Lyn Dupre) за тысячи подробных комментариев в \nотношении рукописи, которые помогли не только избежать и исправить грамматические\nошибки, но и (что значительно важнее) выработать последовательный и связный стиль\nнаписания, что позволило собрать воедино устрашающую массу технического материала. \nЯ исключительно благодарен полученной возможности поучиться у Стива и Лин -\nих вклад в разработку этой книги оказался решающим.\n</p>\n<p>\nМногое из написанного здесь я узнал из лекций и трудов Дона Кнута (Don\nKnuth) - моего наставника в Стэнфорде. Хотя непосредственно Дон и не участвовал\nв написании этой книги, его влияние можно почувствовать на всем ее протяжении,\nибо именно он поставил изучение алгоритмов на научную основу, благодаря чему \nвообще стало возможным появление подобного рода книг. Мой друг и коллега Филлип\nФлажоле (Philippe Flajolet), благодаря которому анализ алгоритмов стал вполне \nсформировавшейся областью исследований, оказал такое же влияние этот труд.\n</p>\n<p>\nЯ глубоко признателен за оказанную мне поддержку Принстонскому университету,\nБрауновскому университету и Национальному институту исследований в области \nинформатики и автоматики (INRIA - Institute de Recherche en Informatique and\nAutomatique), где я проделал большую часть работы над книгой, а также Институту\nисследований проблем безопасности и Исследовательскому центру компании Xerox в\nПало-Альто, где была проделана часть работы во время моих визитов туда. В основу\nмногих глав этой книги положены исследования, которые щедро финансировались\nНациональным научным фондом и Отделом военно-морских исследований. И в заключение, \nя благодарю Билла Боуэна (Bill Bowen), Аарона Лемоника (Aaron Lemonick) и\nНейла Руденштайна (Neil Rudenstine) за то, что они способствовали созданию в\nПринстоне академической обстановки, в которой я получил возможность подготовить\nэту книгу, несмотря на множество других возложенных на меня обязанностей.\n</p>\n<p>\nРоберт Седжвик\nМарли-де-Руа, Франция, февраль 1983 г.\nПринстон, Нью-Джерси, январь 1990 г.\nДжеймстаун, Род-Айленд, август 2001 г.\nАдаму, Эндрю, Бретт, Робби и, в первую очередь, Линде посвящается.\n</p>\n"},{"label":"Примечания к упражнениям","text":"\n<p>\nКЛАССИФИКАЦИЯ УПРАЖНЕНИЙ - это занятие, сопряженное с рядом трудностей, \nпоскольку читатели такой книги, как эта, обладают различным уровнем знаний и опыта.\nТем не менее, определенное указание не помешает, поэтому многие упражнения помечены \nодним из четырех маркеров, дабы проще было выбрать соответствующий подход.\nУпражнения, которые проверяют, насколько хорошо вы усвоили материал, помечены\nнезаполненным треугольником:\n>\t17.3. Составьте список неизоморфных циклов графа, представленного на рис. 17.1.\nНапример, если в вашем списке содержится цикл 3-4-5-3, в нем не могут находиться \nциклы 3-5-4-3, 4-5-3-4, 4-3-5-4, 5-3-4-5 или 5-4-3-5.\nЧаще всего такие упражнения непосредственно связаны с примерами в тексте.\nОни не должны вызывать особых трудностей, но их выполнение может прояснить\nфакт или понятия, которые, возможно, ускользнули из вашего внимания во время\nчтения текста.\nУпражнения, которые дополняют текст новой и требующей размышления информацией, \nпомечены незаполненной окружностью:\nо 18.6. Реализуйте DFS, используя свою независимую от представления АТД-функ-\nцию для обработки списков ребер из упражнения 17.60.\nТакие упражнения заставляют сосредоточиться на важных понятиях, связанных с\nматериалом, наложенным в тексте, или искать ответа на вопрос, который может \nвозникнуть во время прочтения. Возможно, читатели сочтут полезным прочесть эти \nупражнения дбже при отсутствии времени для их выполнения.\nУпражнения, которые имеют цель поставить перед читателями задачу, помечены\nчерной точкой:\n•\t19.2. Назовите пример крупного графа DAG, описывающего какую-нибудь деятельность, \nвыполняемую в интерактивном режиме, возможно, графа, определяемого зависимостями, \nсвязывающими определения функций в крупной системе программного обеспечения, \nили связями каталогов в крупной файловой системе.\nДля выполнения таких упражнений требуется потратить значительное время, в \nзависимости от опыта читателя. В общем случае, лучше всего выполнять их в несколько\nприемов.\nНесколько упражнений, которые особенно трудны (по сравнению с большинством\nдругих) помечены двумя черными точками:\n•• 20.77. Разработайте алгоритм, который при заданном множестве N точек на \nплоскости находит множество ребер, мощность которого пропорциональна N, и \nв котором наверняка содержится дерево MST. Этот алгоритм должен содержать \nдостаточно легкие вычисления, чтобы можно было разработать компактную и\nэффективную реализацию.\nЭти упражнения аналогичны вопросам, которые могут ставиться в научной литературе,\nоднако материал книги может так подготовить читателей, что им доставит \nудовольствие попытаться ответить на них (а, возможно, и преуспеть в этом).\nМы старались, чтобы все пометки были безотносительны к программной и математической \nподготовке читателей. Те упражнения, которые требуют наличия опыта по\nпрограммированию или математическому анализу, очевидны. Мы настоятельно рекомендуем \nчитателям проверить свое понимание алгоритмов, реализовав их. Тем не менее, \nупражнения, подобные приведенному ниже, просты для профессиональных программистов \nили студентов, изучающих программирование, но могут потребовать значительных усилий \nот тех, кто в последнее время по ряду причин программированием не занимался:\n•\t17.73. Напишите программу, которая генерирует V случайных точек на плоскости,\nпосле чего строит граф, состоящий из ребер, соединяющих все пары точек, удаленных \nдруг от друга на расстояние, не превышающее d (см. рис. 17.13 и программу 3.20). \nОпределите, какое значение d следует выбрать, чтобы ожидаемое число\nребер было равно Е. Проведите тестирование полученной программы в соответствии с\nизложенным в упражнении 17.64 (для низких уровней насыщенности) и в соответствии\nс изложенным в упражнении 17.65 (для высоких уровней насыщенности).\nМы настоятельно рекомендуем всем читателям стремиться учитывать приводимые\nнами аналитические обоснования свойств всех алгоритмов. С другой стороны, упражнения, \nподобные нижеследующему, не составляют сложности для профессионального\nматематика или студента, изучающего дискретную математику, однако наверняка потребуют \nзначительных усилий от тех, кто давно не занимался математическим анализом:\n•\t18.3. Сколько существует путей обхода лабиринта, показанного на рис. 18.2 и 18.3,\nпри проведении исследования Тремо?\nКнига снабжена большим количеством упражнений, чтобы всех их можно было\nпрочесть и усвоить; тем не менее, я надеюсь, что среди них достаточно таких, которые \nмогут послужить мощным стимулом к углубленному пониманию интересующих их\nвопросов, нежели простое чтение текста.\n</p>\n"}]}